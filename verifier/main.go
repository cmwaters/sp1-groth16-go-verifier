package main

import (
	"bytes"
	"crypto/sha256"
	"encoding/hex"
	"fmt"
	"log"
	"math/big"
	"os"
	"strings"

	"github.com/consensys/gnark-crypto/ecc"
	curve "github.com/consensys/gnark-crypto/ecc/bn254"
	fr_bn254 "github.com/consensys/gnark-crypto/ecc/bn254/fr"
	"github.com/consensys/gnark/backend/groth16"
	bn254 "github.com/consensys/gnark/backend/groth16/bn254"
	"github.com/consensys/gnark/backend/witness"
)

func main() {
	fmt.Println("Starting Groth16 proof verification...")

	// Read the proof file
	proofBytes, err := os.ReadFile("output/proof.bin")
	if err != nil {
		log.Fatalf("Error reading proof file: %v", err)
	}
	fmt.Printf("Read proof file: %d bytes\n", len(proofBytes))

	// Read the public inputs file
	sp1PublicInputsBytes, err := os.ReadFile("output/sp1_public_inputs.bin")
	if err != nil {
		log.Fatalf("Error reading public inputs file: %v", err)
	}
	fmt.Printf("Read public inputs file: %X (%d bytes) \n", sp1PublicInputsBytes, len(sp1PublicInputsBytes))

	// Read the SP1	verifier key file
	sp1VkBytes, err := os.ReadFile("output/verifier_key.bin")
	if err != nil {
		log.Fatalf("Error reading SP1 verifier key file: %v", err)
	}
	fmt.Printf("Read SP1 verifier key file: %d bytes\n", len(sp1VkBytes))

	// Read the groth16 verifier key file
	groth16VkBytes, err := os.ReadFile("groth16_vk.bin")
	if err != nil {
		log.Fatalf("Error reading groth16 verifier key file: %v", err)
	}
	fmt.Printf("Read groth16 verifier key file: %d bytes\n", len(groth16VkBytes))

	groth16VkHash := sha256.Sum256(groth16VkBytes)

	// Compare first 4 bytes
	if !bytes.Equal(groth16VkHash[:4], proofBytes[:4]) {
		log.Fatalf("First 4 bytes of verifier key hash (%x) do not match proof hash (%x)", groth16VkHash[:4], proofBytes[:4])
	}
	fmt.Printf("First 4 bytes of hashes match: %x\n", groth16VkHash[:4])
	proofBytes = proofBytes[4:]

	// Unmarshal the verifier key
	vk := groth16.NewVerifyingKey(ecc.BN254)
	_, err = vk.ReadFrom(bytes.NewReader(groth16VkBytes))
	if err != nil {
		log.Fatalf("Error unmarshaling verifier key: %v", err)
	}
	fmt.Println("Successfully unmarshaled verifier key")

	proof := &bn254.Proof{}
	dec := curve.NewDecoder(bytes.NewReader(proofBytes))

	if err := dec.Decode(&proof.Ar); err != nil {
		log.Fatalf("Error unmarshaling proof: %v", err)
	}
	if err := dec.Decode(&proof.Bs); err != nil {
		log.Fatalf("Error unmarshaling proof: %v", err)
	}
	if err := dec.Decode(&proof.Krs); err != nil {
		log.Fatalf("Error unmarshaling proof: %v", err)
	}

	fmt.Println("Successfully constructed proof from affine points")

	// Create witness from public inputs
	// Note: This is a simplified approach - in practice, you'd need to know
	// the exact structure of the public inputs for your specific circuit
	w, err := witness.New(ecc.BN254.ScalarField())
	if err != nil {
		log.Fatalf("Error creating witness: %v", err)
	}

	sp1PublicInputsHash := sha256.Sum256(sp1PublicInputsBytes)

	// Read the verifier key hash hex file
	vkHashHex, err := os.ReadFile("output/verifier_key_hash.hex")
	if err != nil {
		log.Fatalf("Error reading verifier key hash hex file: %v", err)
	}

	// Remove "0x" prefix if present
	hexStr := strings.TrimPrefix(string(vkHashHex), "0x")

	// Decode hex string to bytes
	vkHashBytes, err := hex.DecodeString(hexStr)
	if err != nil {
		log.Fatalf("Error decoding hex string: %v", err)
	}

	// Convert bytes to big.Int
	vkHashBigInt := new(big.Int).SetBytes(vkHashBytes)
	fmt.Printf("Verifier key hash from hex file (decimal): %d\n", vkHashBigInt)

	// Zero out first 3 bits of each hash to comply with BN254 field elements
	sp1PublicInputsHash[0] &= 0b00011111

	// Convert hashes to big.Int and print
	sp1PublicInputsHashInt := new(big.Int).SetBytes(sp1PublicInputsHash[:])
	fmt.Printf("sp1PublicInputsHash (decimal): %d\n", sp1PublicInputsHashInt)

	// Convert big.Ints to fr_bn254.Element format
	var vkElement fr_bn254.Element
	_ = vkElement.SetBigInt(vkHashBigInt)

	var publicInputsElement fr_bn254.Element
	_ = publicInputsElement.SetBigInt(sp1PublicInputsHashInt)

	groth16PublicInputs := make(chan any)
	go func() {
		defer close(groth16PublicInputs)
		groth16PublicInputs <- vkElement
		groth16PublicInputs <- publicInputsElement
	}()

	if err := w.Fill(2, 0, groth16PublicInputs); err != nil {
		log.Fatalf("Error filling witness: %v", err)
	}

	publicWitness, err := w.Public()
	if err != nil {
		log.Fatalf("Error getting public witness: %v", err)
	}
	fmt.Println("Successfully created public witness")

	// Verify the proof
	fmt.Println("Attempting to verify the proof...")
	err = groth16.Verify(proof, vk, publicWitness)
	if err != nil {
		log.Printf("Proof verification failed: %v", err)
		os.Exit(1)
	}

	fmt.Println("ðŸŽ‰ Proof verification successful!")
	fmt.Println("The Groth16 proof generated by SP1 has been successfully verified using gnark!")
}
