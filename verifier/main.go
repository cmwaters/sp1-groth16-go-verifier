package main

import (
	"bytes"
	"crypto/sha256"
	"fmt"
	"log"
	"math/big"
	"os"

	"github.com/consensys/gnark-crypto/ecc"
	curve "github.com/consensys/gnark-crypto/ecc/bn254"
	fr_bn254 "github.com/consensys/gnark-crypto/ecc/bn254/fr"
	"github.com/consensys/gnark/backend/groth16"
	bn254 "github.com/consensys/gnark/backend/groth16/bn254"
	"github.com/consensys/gnark/backend/witness"
)

func main() {
	fmt.Println("Starting Groth16 proof verification...")

	// Read the proof file
	proofBytes, err := os.ReadFile("output/proof.bin")
	if err != nil {
		log.Fatalf("Error reading proof file: %v", err)
	}
	fmt.Printf("Read proof file: %d bytes\n", len(proofBytes))

	// Read the public inputs file
	sp1PublicInputsBytes, err := os.ReadFile("output/sp1_public_inputs.bin")
	if err != nil {
		log.Fatalf("Error reading public inputs file: %v", err)
	}
	fmt.Printf("Read public inputs file: %X (%d bytes) \n", sp1PublicInputsBytes, len(sp1PublicInputsBytes))

	// Read the SP1	verifier key file
	sp1VkBytes, err := os.ReadFile("output/verifier_key.bin")
	if err != nil {
		log.Fatalf("Error reading SP1 verifier key file: %v", err)
	}
	fmt.Printf("Read SP1 verifier key file: %d bytes\n", len(sp1VkBytes))

	// Read the groth16 verifier key file
	groth16VkBytes, err := os.ReadFile("groth16_vk.bin")
	if err != nil {
		log.Fatalf("Error reading groth16 verifier key file: %v", err)
	}
	fmt.Printf("Read groth16 verifier key file: %d bytes\n", len(groth16VkBytes))

	sp1VkHash := sha256.Sum256(sp1VkBytes)

	// Compare first 4 bytes
	if !bytes.Equal(sp1VkHash[:4], proofBytes[:4]) {
		log.Fatalf("First 4 bytes of verifier key hash (%x) do not match proof hash (%x)", sp1VkHash[:4], proofBytes[:4])
	}
	fmt.Printf("First 4 bytes of hashes match: %x\n", sp1VkHash[:4])
	proofBytes = proofBytes[4:]

	// Unmarshal the verifier key
	vk := groth16.NewVerifyingKey(ecc.BN254)
	_, err = vk.ReadFrom(bytes.NewReader(groth16VkBytes))
	if err != nil {
		log.Fatalf("Error unmarshaling verifier key: %v", err)
	}
	fmt.Println("Successfully unmarshaled verifier key")

	proof := &bn254.Proof{}
	dec := curve.NewDecoder(bytes.NewReader(proofBytes))

	if err := dec.Decode(&proof.Ar); err != nil {
		log.Fatalf("Error unmarshaling proof: %v", err)
	}
	if err := dec.Decode(&proof.Bs); err != nil {
		log.Fatalf("Error unmarshaling proof: %v", err)
	}
	if err := dec.Decode(&proof.Krs); err != nil {
		log.Fatalf("Error unmarshaling proof: %v", err)
	}

	fmt.Println("Successfully constructed proof from affine points")

	// Create witness from public inputs
	// Note: This is a simplified approach - in practice, you'd need to know
	// the exact structure of the public inputs for your specific circuit
	w, err := witness.New(ecc.BN254.ScalarField())
	if err != nil {
		log.Fatalf("Error creating witness: %v", err)
	}

	sp1PublicInputsHash := sha256.Sum256(sp1PublicInputsBytes)

	// Zero out first 3 bits of each hash to comply with BN254 field elements
	sp1PublicInputsHash[0] &= 0b00011111

	// Convert hashes to big.Int and print
	sp1PublicInputsHashInt := new(big.Int).SetBytes(sp1PublicInputsHash[:])
	sp1VkHashInt := new(big.Int).SetBytes(sp1VkHash[1:])
	fmt.Printf("sp1VkHash (decimal): %d\n", sp1VkHashInt)
	fmt.Printf("sp1PublicInputsHash (decimal): %d\n", sp1PublicInputsHashInt)

	// Convert big.Ints to fr_bn254.Vector format
	vkVector := make(fr_bn254.Vector, 1)
	if err := vkVector[0].SetBigInt(sp1VkHashInt); err != nil {
		log.Fatalf("Error converting vk hash to field element: %v", err)
	}

	publicInputsVector := make(fr_bn254.Vector, 1)
	if err := publicInputsVector[0].SetBigInt(sp1PublicInputsHashInt); err != nil {
		log.Fatalf("Error converting public inputs hash to field element: %v", err)
	}

	groth16PublicInputs := make(chan any)
	go func() {
		defer close(groth16PublicInputs)
		groth16PublicInputs <- vkVector
		groth16PublicInputs <- publicInputsVector
	}()

	if err := w.Fill(2, 0, groth16PublicInputs); err != nil {
		log.Fatalf("Error filling witness: %v", err)
	}

	publicWitness, err := w.Public()
	if err != nil {
		log.Fatalf("Error getting public witness: %v", err)
	}
	fmt.Println("Successfully created public witness")

	// Verify the proof
	fmt.Println("Attempting to verify the proof...")
	err = groth16.Verify(proof, vk, publicWitness)
	if err != nil {
		log.Printf("Proof verification failed: %v", err)
		os.Exit(1)
	}

	fmt.Println("ðŸŽ‰ Proof verification successful!")
	fmt.Println("The Groth16 proof generated by SP1 has been successfully verified using gnark!")
}
